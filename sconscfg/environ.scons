from SCons.Subst import quote_spaces
from SCons.Platform import TempFileMunge

import SCons
import os
import sys
import re
import multiprocessing

TOOLCHAIN_PREFIX = "arm-none-eabi-"

vars = Variables(None, ARGUMENTS)
vars.Add(BoolVariable("DEBUG", help="Enable debug build", default=1))
vars.Add(BoolVariable("COMPACT", help="Optimize for size", default=0))
vars.Add(
    BoolVariable("RAM_EXEC", help="Build updater image for RAM exection", default=0)
)

env = Environment(
    variables=vars,
    tools=["as", "gcc", "g++", "ar", "gnulink", "python", "compilation_db"],
    # CC="arm-none-eabi-gcc",
    # CXX="arm-none-eabi-g++",
    # LINK="arm-none-eabi-g++",
    # CCFLAGS=[],
    # LINKFLAGS=[],
    OBJCOPY="objcopy",
    PYTHON3="python3",
    TEMPFILE=TempFileMunge,
    MAXLINELENGTH=2048,
    PROGSUFFIX=".elf",
    COMPILATIONDB_USE_ABSPATH=True,
    ENV={
        "PATH": os.environ["PATH"],
    },
)

if env["PLATFORM"] == "win32":
    # On Windows, python 3 executable is usually just "python"
    env["PYTHON3"] = env["PYTHON3"][:-1]

Help(vars.GenerateHelpText(env))

# Default value for -j

SetOption("num_jobs", multiprocessing.cpu_count())
SetOption("implicit_cache", True)


# Setting up temp file parameters

WINPATHSEP_RE = re.compile(r"\\([^\"'\\]|$)")


def tempfile_arg_esc_func(arg):
    arg = quote_spaces(arg)
    if sys.platform != "win32":
        return arg
    # GCC requires double Windows slashes, let's use UNIX separator
    return WINPATHSEP_RE.sub(r"/\1", arg)


env["TEMPFILEARGESCFUNC"] = tempfile_arg_esc_func

# Set up cross-compile tools
for binary in [
    "AR",
    "AS",
    "CC",
    "CXX",
    # "LINK",
    # "RANLIB",
    "OBJCOPY",
    # "OBJDUMP",
    # "OBJSYMBOLS",
]:
    env[binary] = TOOLCHAIN_PREFIX + env[binary]

# Commandline length limit hack
env["LINKCOM"] = '${TEMPFILE("' + env["LINKCOM"] + '","$LINKCOMSTR")}'

# Recursive glob
def GlobRecursive(pattern, node=".", exclude=None):
    results = []
    for f in Glob(str(node) + "/*", source=True, exclude=exclude):
        if type(f) is SCons.Node.FS.Dir:
            # print(f"recursing into {f}")
            results += GlobRecursive(pattern, f, exclude)
    current_node_str = str(node) + "/"
    results += Glob(
        current_node_str + pattern,
        source=True,
        exclude=exclude and current_node_str + exclude or exclude,
    )
    return results


env.GlobRecursive = GlobRecursive


def check_exists(path):
    # print("checking", File(path).abspath)
    return os.path.exists(File(path).abspath)


def build_module(env, module):
    print("module")
    module_sconscript = f"{module}/SConscript"
    if not check_exists(module_sconscript):
        module_sconscript = f"{module}.scons"
        if not check_exists(module_sconscript):
            print(f"Cannot build module {module}: scons file not found")
            Exit(2)

    # # module_sconscript = os.path.join(module, "SConscript")
    # print("check for ", module_sconscript)
    # if not os.path.exists(module_sconscript):
    #     module_sconscript = f"{module}.scons"

    print("sub-building", module_sconscript)
    return env.SConscript(
        module_sconscript,
        # variant_dir=module + "/obj",
        # variant_dir=env["BUILD_DIR"],
        duplicate=0,
    )


def BuildModules(env, modules):
    print("build list", modules)
    result = []
    for module in modules:
        build_res = build_module(env, module)
        # print("module ", module, build_res)
        if build_res is None:
            continue
        elif isinstance(build_res, list):
            result.extend(build_res)
        else:
            result.append(build_res[0])  # ???
    return result


env.BuildModules = BuildModules

lib_flags = {
    "CCFLAGS": [
        "-Os",
    ],
    "CPPDEFINES": [
        "NDEBUG",
    ],
}

Export("env", "lib_flags")
