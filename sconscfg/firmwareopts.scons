Import("fwenv")


if fwenv["DEBUG"]:
    fwenv.Append(
        CPPDEFINES=[
            "FURI_DEBUG",
            "NDEBUG",
        ],
        CCFLAGS=[
            "-Og",
            "-g",
        ],
    )
elif fwenv["COMPACT"]:
    fwenv.Append(
        CPPDEFINES=[
            "FURI_NDEBUG",
            "NDEBUG",
        ],
        CCFLAGS=[
            "-Os",
            "-g",
        ],
    )
else:
    fwenv.Append(
        CPPDEFINES=[
            "FURI_NDEBUG",
            "NDEBUG",
        ],
        CCFLAGS=[
            "-Og",
            "-g",
        ],
    )

fwenv.Append(
    OPENOCD_OPTS='-f interface/stlink.cfg -c "transport select hla_swd" -f debug/stm32wbx.cfg -c "stm32wbx.cpu configure -rtos auto" -c "init"',
)

if fwenv["FIRMWARE_BUILD_CFG"] == "updater":
    fwenv.Append(
        CPPDEFINES=[
            "FURI_RAM_EXEC",
            "VECT_TAB_SRAM",
            "FLIPPER_STREAM_LITE",
        ],
        IMAGE_BASE_ADDRESS="0x20000000",
        LINKFLAGS=[
            "-Tfirmware/targets/f${TARGET_HW}/stm32wb55xx_ram_fw.ld",
        ],
    )
else:
    fwenv.Append(
        IMAGE_BASE_ADDRESS="0x8000000",
        LINKFLAGS=[
            "-Tfirmware/targets/f${TARGET_HW}/stm32wb55xx_flash.ld",
        ],
    )


from dataclasses import dataclass, field
from typing import List, Set, Dict, Tuple, Optional
from enum import Enum
import os
import SCons


class FlipperAppType(Enum):
    SERVICE = "Service"
    SYSTEM = "System"
    APP = "App"
    PLUGIN = "Plugin"
    DEBUG = "Debug"
    ARCHIVE = "Archive"
    SETTINGS = "Settings"
    STARTUP = "StartupHook"


@dataclass
class FlipperApplication:
    appid: str
    apptype: FlipperAppType
    name: Optional[str] = None
    entry_point: Optional[str] = None
    flags: List[str] = field(default_factory=lambda: ["Default"])
    cdefines: List[str] = field(default_factory=list)
    requires: List[str] = field(default_factory=list)
    conflicts: List[str] = field(default_factory=list)
    provides: List[str] = field(default_factory=list)
    stack_size: int = 2048
    icon: Optional[str] = None
    order: int = 0
    _appdir: Optional[str] = None


class AppManager:
    def __init__(self):
        self.known_apps = {}

    def get(self, appname: str):
        return self.known_apps[appname]

    def load_manifest(self, app_manifest_path: str, app_dir_name: str):
        if not os.path.exists(app_manifest_path):
            raise Exception(f"App manifest  not found at path {app_manifest_path}")
        # print("Loading", app_manifest_path)

        app_manifests = []

        def App(*args, **kw):
            nonlocal app_manifests
            app_manifests.append(FlipperApplication(*args, **kw, _appdir=app_dir_name))

        with open(app_manifest_path, "rt") as manifest_file:
            exec(manifest_file.read())

        if len(app_manifests) == 0:
            Exit(f"App manifest '{app_manifest_path}' is malformed")

        # print("Built", app_manifests)
        for app in app_manifests:
            self._add_known_app(app)

    def _add_known_app(self, app: FlipperApplication):
        if self.known_apps.get(app.appid, None):
            raise Exception(f"Duplicate app declaration: {app.appid}")
        self.known_apps[app.appid] = app

    def filter_apps(self, applist: List[str]):
        return AppBuildset(self, applist)


class AppBuildset:
    def __init__(self, appmgr: AppManager, appnames: List[str]):
        self.appmgr = appmgr
        self.appnames = set(appnames)
        self._orig_appnames = appnames
        self._process_deps()
        self._check_conflicts()
        self._check_unsatisfied()  # unneeded?
        self.apps = list(self.appmgr.get(appname) for appname in self.appnames)

    def _is_missing_dep(self, dep_name):
        return dep_name not in self.appnames

    def _process_deps(self):
        while True:
            provided = []
            for app in self.appnames:
                # print(app)
                provided.extend(
                    filter(
                        self._is_missing_dep,
                        self.appmgr.get(app).provides + self.appmgr.get(app).requires,
                    )
                )
            # print("provides round", provided)
            if len(provided) == 0:
                break
            self.appnames.update(provided)

    def _check_conflicts(self):
        conflicts = []
        for app in self.appnames:
            # print(app)
            if conflict_app_name := list(
                filter(
                    lambda dep_name: dep_name in self.appnames,
                    self.appmgr.get(app).conflicts,
                )
            ):
                conflicts.append((app, conflict_app_name))

        if len(conflicts):
            raise Exception(
                f"App conflicts for {', '.join(f'{conflict_dep[0]}: {conflict_dep[1]}' for conflict_dep in conflicts)}"
            )

    def _check_unsatisfied(self):
        unsatisfied = []
        for app in self.appnames:
            if missing_dep := list(
                filter(self._is_missing_dep, self.appmgr.get(app).requires)
            ):
                unsatisfied.append((app, missing_dep))

        if len(unsatisfied):
            raise Exception(
                f"Unsatisfied dependencies for {', '.join(f'{missing_dep[0]}: {missing_dep[1]}' for missing_dep in unsatisfied)}"
            )

    def get_apps_cdefs(self):
        cdefs = set()
        for app in self.apps:
            cdefs.update(app.cdefines)
        return sorted(list(cdefs))

    def get_apps_of_type(self, apptype: FlipperAppType):
        return sorted(
            filter(lambda app: app.apptype == apptype, self.apps),
            key=lambda app: app.order,
        )


def LoadApplicationManifests(env):
    appmgr = env["APPMGR"] = AppManager()
    for entry in Glob("#/applications/*"):
        if isinstance(entry, SCons.Node.FS.Dir):
            appmgr.load_manifest(entry.File("application.fam").abspath, entry.name)

    print(f"Loaded {len(appmgr.known_apps)} app definitions.")


fwenv.AddMethod(LoadApplicationManifests)
fwenv.LoadApplicationManifests()

# "updater_app", "bt", "desktop""
apps_buildlist = fwenv["APPMGR"].filter_apps(
    [
        "crypto_start",
        # Svc
        "rpc",
        "bt",
        "desktop",
        "loader",
        "power",
        # Arch
        "archive",
        # Apps
        "gpio",
        "ibutton",
        "infrared",
        "lfrfid",
        "nfc",
        "subghz",
        "bad_usb",
        "u2f",
        "updater_app",
        # Settings
        "passport",
        "system_settings",
        "about",
        # Plugins
        "music_player",
        "snake_game",
        "bt_hid",
        # Debug
        "blink_test",
        "vibro_test",
        "keypad_test",
        "usb_test",
        "usb_mouse",
        "uart_echo",
        "display_test",
        "text_box_test",
        "infrared_monitor",
    ]
)
# print("apps_buildlist", apps_buildlist.apps)
for apptype in FlipperAppType:
    print(
        apptype,
        ":",
        ", ".join(app.appid for app in apps_buildlist.get_apps_of_type(apptype)),
    )
print("cdefs", apps_buildlist.get_apps_cdefs())
# print
# print("svc", apps_buildlist.get_apps_of_type(FlipperAppType.SERVICE))
# Exit(1)
